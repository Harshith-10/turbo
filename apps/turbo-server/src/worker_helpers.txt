
// Helper for async recursive copy
async fn copy_dir_recursive(src: &Path, dst: &Path) -> std::io::Result<()> {
    if !dst.exists() {
        fs::create_dir_all(dst).await?;
    }
    let mut entries = fs::read_dir(src).await?;
    while let Some(entry) = entries.next_entry().await? {
        let ty = entry.file_type().await?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());
        if ty.is_dir() {
            Box::pin(copy_dir_recursive(&src_path, &dst_path)).await?;
        } else {
            fs::copy(&src_path, &dst_path).await?;
        }
    }
    Ok(())
}

fn calculate_job_hash(req: &turbo_core::models::JobRequest, compile_script_content: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(req.language.as_bytes());
    hasher.update(req.version.as_deref().unwrap_or("latest").as_bytes());
    hasher.update(compile_script_content.as_bytes());

    // Sort files to ensure stable hash
    let mut files = req.files.clone();
    files.sort_by(|a, b| a.name.cmp(&b.name));

    for file in files {
        hasher.update(file.name.as_deref().unwrap_or("main").as_bytes());
        hasher.update(&file.content);
    }

    hex::encode(hasher.finalize())
}
